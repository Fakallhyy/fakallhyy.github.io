<!DOCTYPE html>


<html lang="zh-cn">


<head>
  <meta charset="utf-8" />
    
  <meta name="description" content="Fakallhyy的博客" />
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
  <title>
    Redis6 |  Fakallhyy的博客
  </title>
  <meta name="generator" content="hexo-theme-ayer">
  
  <link rel="shortcut icon" href="/favicon.ico" />
  
  
<link rel="stylesheet" href="/dist/main.css">

  
<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Shen-Yu/cdn/css/remixicon.min.css">

  
<link rel="stylesheet" href="/css/custom.css">

  
  
<script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script>

  
  

  

</head>

</html>

<body>
  <div id="app">
    
      <canvas class="fireworks"></canvas>
      <style>
        .fireworks {
          position: fixed;
          left: 0;
          top: 0;
          z-index: 99999;
          pointer-events: none;
        }
      </style>
      
      
    <main class="content on">
      <section class="outer">
  <article
  id="post-redis6"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h1 class="article-title sea-center" style="border-left:0" itemprop="name">
  Redis6
</h1>
 

    </header>
     
    <div class="article-meta">
      <a href="/2022/01/29/redis6/" class="article-date">
  <time datetime="2022-01-29T12:41:12.000Z" itemprop="datePublished">2022-01-29</time>
</a>   
<div class="word_count">
    <span class="post-time">
        <span class="post-meta-item-icon">
            <i class="ri-quill-pen-line"></i>
            <span class="post-meta-item-text"> Word count:</span>
            <span class="post-count">11.8k</span>
        </span>
    </span>

    <span class="post-time">
        &nbsp; | &nbsp;
        <span class="post-meta-item-icon">
            <i class="ri-book-open-line"></i>
            <span class="post-meta-item-text"> Reading time≈</span>
            <span class="post-count">44 min</span>
        </span>
    </span>
</div>
 
    </div>
      
    <div class="tocbot"></div>




  
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="NoSQL数据库"><a href="#NoSQL数据库" class="headerlink" title="NoSQL数据库"></a>NoSQL数据库</h1><p>解决性能问题，性能优先<br>NoSQl不依赖业务逻辑方式存储，以key-value模式存储，大大增加了数据库的扩展能力</p>
<ul>
<li>不支持SQL标准</li>
<li>不支持ACID（原子性（atomicity，或称不可分割性）、一致性（consistency）、隔离性（isolation，又称独立性）、持久性（durability））</li>
<li>远超SQL的性能</li>
</ul>
<p>高并发，海量数据，数据高拓展性</p>
<h2 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h2><p><a target="_blank" rel="noopener" href="https://try.redis.io/">在线Redis实操</a></p>
<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>安装到Ubuntu里边了<br>先下载tar.gz源码包<br>然后解压tar -zxvf tar.gz<br>然后cd到目录 make<br>然后到src下 make install<br>默认安装位置在/user/local/bin</p>
<p>运行就是redis-server(前台启动)<br>后台启动需要配置文件 daemonize no-&gt;yes<br>redis-server /etc/redis.config<br>查看redis ps -ef | grep redis</p>
<p>redis -cli 就是(后台启动之后)连接redis 可以输入ping 返回PONG<br>redis -cli shutdown就是关闭</p>
<h3 id="相关知识"><a href="#相关知识" class="headerlink" title="相关知识"></a>相关知识</h3><p>redis通过C语言实现了多路复用 轮询的机制,保证了高性能(NIO)</p>
<ul>
<li>端口6379 - Merz</li>
<li>默认16个数据库，从0开始，初始默认使用0号库</li>
<li>使用select dbid 来切换数据库。如:select 8</li>
<li>统一密码管理，所有库同样密码</li>
<li>dbsize查看当前数据库的key的数量</li>
<li>flushdb清空当前库</li>
<li>flushall清空所有库</li>
</ul>
<p><strong>Redis 是单线程+多路IO复用技术</strong></p>
<p>&nbsp;多路复用是使用一个线程来检查多个文件描述符(Socket)的就绪状态，比如调用select和pool函数，传入多个文件描述符，如果有一个文件描述符就绪，则返回，否则阻塞到超时。得到就绪状态后进行真正的操作可以在同一个线程里执行，也可以启动线程执行(比如使用线程池)</p>
<p><strong>串行 vs 多线程+锁（memcached） vs 单线程+多路IO复用（redis）</strong></p>
<p>redis和Memcache三点不同:支持多数据类型，支持持久化(虽然存储在内存中，但是会定期存储到磁盘中)，单线程+多路IO复用</p>
<h3 id="Redis键-key"><a href="#Redis键-key" class="headerlink" title="Redis键(key)"></a>Redis键(key)</h3><p>set key value 添加</p>
<p>keys * 查看当前库所有key （匹配:keys *1）<br>exists key 判断某个key是否存在<br>type key 查看你的key是什么类型<br>del key 删除指定的key数据<br>unlink key 根据value选择非阻塞删除(仅将keys从keyspace元数据中删除，真正的删除会在后续异步操作)</p>
<p>expire key 10  10秒钟:为给定的key设置过期时间<br>ttl key 查看还有多少秒过期，-1表示永不过期，-2表示已过期</p>
<h4 id="五大数据类型"><a href="#五大数据类型" class="headerlink" title="五大数据类型"></a>五大数据类型</h4><h5 id="String"><a href="#String" class="headerlink" title="String"></a>String</h5><p>是Redis中最基本的类型， 是二进制安全的。意味着Redis的string可以包含任何数据如jpg图片，或者序列化的对象</p>
<p>是redis最基本的类型，一个Redis中字符串value最多可以是512M</p>
<hr>
<p><strong>value的底层实现</strong><br>String的数据结构为简单动态字符串，是可以修改的字符串，内部结构实现上类似于Java的ArrayList，采用预分配冗余空间的方式减少内存的频繁分配。</p>
<p><img src="https://s1.328888.xyz/2022/08/09/0zxi5.png" alt="String"></p>
<hr>
<p>set key value 添加键值对，相同key会覆盖<br>get key  查询对应键值<br>append key value 将给定的value追加到原值末尾。返回长度<br>strlen key 获取值的长度<br>setnx key value 只有key不存在时 设置key的值</p>
<p>incr key 将key对应的value中存储的数字值增一，只能对数字值操作，如果为空，新增值为1<br>decr key 将key对应的value中储存的数字值减一，只能对数字值操作，如果为空，新增值为-1</p>
<p>mset key value key value ….  添加多个键值对，相同key会覆盖<br>mget key  查询多个key对应键值<br>msetnx key value key value …. ———- 只有多个都key不存在时 设置key的值 <strong>原子性</strong></p>
<p>getrange key value起始位置 value结束位置 – 获取value的起始-结束<br>setrange key 起始位置 value字符 ———– 从起始位置改变</p>
<p>setex key 过期时间 value 设置键值的同事，设置过期时间<br>getset key value 以新值换旧值，会返回旧值</p>
<p><strong>原子性</strong><br>所谓原子操作是指不会被线程调度机制打断的操作<br>操作一旦开始，就一直运行到结束，中间不会有任何context switch(切换到另一个线程)</p>
<ul>
<li>单线程中，能够在单条指令中完成的操作都可以认为是原子操作，因为中断只能发生于指令之间</li>
<li>在多线程中，不能被其他进程(线程)打断的操作就叫原子操作。</li>
</ul>
<p>redis单命令的原子性主要得益于Redis的单线程</p>
<p><strong>java中的i++是否是原子操作</strong></p>
<p>i=0; 两个线程分别对i进行++100次，值是多少?<br>i++ 先将i赋给新变量 然后++ </p>
<p>i++分为取值 ， ++ ，赋值操作<br>极端情况：b抢到线权，开始取值取到0，还没开始++时a抢到了线权，i取值为0，一直加到99；<br>b又抢回线权，开始++操作，i从0加到1。a中i=99就相当于被覆盖了，此时a只能再加1次了，b还能加99次。<br>a抢回线权，取值为1，还没开始++时，又被b抢到线权，i一直加到100结束，a抢回线权，i+1=2，再赋值操作。<br>ab都各自加了100次，最后i就是2。问题出在i++分为三步，取值，++，赋值。a取值后，还没开始++之前，是可以被另一线程b打断的，即使a后面抢回线权，它也不会再取值，会继续执行++操作。</p>
<p><img src="https://s1.328888.xyz/2022/08/09/0zqJ6.png" alt="i"></p>
<h5 id="List"><a href="#List" class="headerlink" title="List"></a>List</h5><p>单键多值<br>Redis列表是简单的字符串列表，按照插入顺序排序。可以添加一个元素到列表的头部(左)或者尾部(右)</p>
<p>它的底层实际是个<strong>双向链表</strong>，对两端的操作性能很高，通过索引下标的操作中间的结点性能会比较差</p>
<hr>
<p>数据结构是快速链表quickList。<br>首先在元素列表比较少的情况下会使用一块连续的内部存储，这个结构是ziplist，也是压缩列表<br>他将所有的元素紧挨着一起存储，分配的是一块连续的内存</p>
<p>当数据量比较多的时候才会改成quicklist。</p>
<p>因为普通的链表需要的附加指针空间太大，比较浪费空间。比如在这个列表里只存了int型的数据，结构上还需要两个额外的指针prew和next</p>
<p>ziplist&lt;–&gt;ziplist&lt;–&gt;ziplist</p>
<p>Redis将链表和ziplist结合起来组成了quicklist。也就是将多个ziplist使用双向指针串起来使用。这样既满足了快速插入性能，又不会出现太大的空间冗余。</p>
<hr>
<p>lpush/rpush key value1 value2   左/右插入<br>lpop/rpop key 左/右吐出一个值。值在键在，值光键亡</p>
<p>rpoplpush key1 key2   key1列表右边吐出一个值，插到key2列表左边</p>
<p>lrange key strat stop 按照索引下标(<strong>0开始</strong>)获得元素 从左到右(0 -1表示所有值)<br>lrange mylist 0 -1   0是左边第一个，-1是右边第一个(0-1表示获取所有)</p>
<p>lindex key index 按照索引下标获得元素(从左到右)<br>llen key 获得列表长度</p>
<p>linsert key before “value” “newvalue” 在value后边插入newvalue<br>lrem key n value 从左边删除n个value(从左到右)<br>lset key index value 将列表key下标为inde的值替换为value</p>
<h5 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h5><p>Redis set 对外提供的功能与list类似，是一个列表的功能，但是set可以自动排重，当你需要存储一个列表数据，又不希望出现重复数据时，set是一个很好的选泽，set提供了判断某个成员是否在一个set集合内的重要接口，这个也是list所不能提供的。</p>
<p>Redis的Set是string类型的<strong>无序集合，它底层是一个value为null的hash表</strong>，所以添加，删除，查找的复杂度都是O(1)。</p>
<p>一个算法，随着数据的增加，执行时间的长短，如果是O（1） 数据增加，查找数据的时间不变</p>
<hr>
<p>Set数据结构是dict字典，字典用哈希表实现的<br>Java中的HashSet的内部实现使用的是HashMap，只不过所有的value都指向同一个对象。Redis的set结构也是一样，它的内部也是用hash结构，所有的value都指向同一个内部值。</p>
<hr>
<p>sadd key value1 value2  将一个或多个member元素加入到集合key中，已经存在的member元素将被忽略<br>smembers key 取出该集合的所有值<br>sismember key value 判断key是否含有value值，有1 没有0<br>scard key 返回该集合的元素个数<br>srem key value1 value2  删除集合中的某个元素<br>spop key  随机从该集合中吐出一个值<br>srandmember key n 随机从该集合中取出n个值，不会从集合中删除<br>smove key1 key2 value 把集合中一个值从一个集合移动到另一个集合<br>sinter key1 key2 返回俩集合的交集<br>sunion key1 key2 返回俩集合的并集<br>sdiff key1 key2 返回差集(key1中有的，key2中没有的)</p>
<h5 id="Hash"><a href="#Hash" class="headerlink" title="Hash"></a>Hash</h5><p>哈希hash是一个string类型的field和value的映射表，适合存储对象，类似java的Map&lt;String,Object&gt;</p>
<p>类似R&lt;&gt;</p>
<hr>
<p>Hash类型对应的数据结构是两种ziplist(压缩列表)，hashtable(哈希表)<br>当field-value长度较短且个数较少时，使用ziplist，否则使用hashtable</p>
<hr>
<p>用户ID为查找的key，存储的value用户对象包含姓名，年龄，生日等信息</p>
<p>hset key1 filed value 给key集合中的 field键赋值value<br>hget key1 filed 从key1集合field取出value<br>hmset key1 filed1 value1 fileld2 value2  批量设置hash的值<br>hexists key1 field  查看哈希表 key 中，给定域 field 是否存在</p>
<p>hkeys key 列出该 hash 集合的所有 field<br>hvals key 列出该 hash 集合的所有 value</p>
<p>hincrby key field increment 为哈希表 key 中的域 field 的值加上增量 1 -1<br>hsetnx key field value 将哈希表 key 中的域 field 的值设置为 value ，当且仅当域 field 不存在</p>
<h5 id="Zset"><a href="#Zset" class="headerlink" title="Zset"></a>Zset</h5><p>有序集合Zset(sorted set)</p>
<p>Redis有序集合zset与普通集合set非常相似，是一个没有重复元素的字符串集合。</p>
<p>不同之处是有序集合的每个成员都关联了一个评分（score）,这个评分（score）被用来按照从最低分到最高分的方式排序集合中的成员。集合的成员是唯一的，但是评分可以是重复了 。</p>
<p>因为元素是有序的, 所以你也可以很快的根据评分（score）或者次序（position）来获取一个范围的元素。<br>访问有序集合的中间元素也是非常快的,因此你能够使用有序集合作为一个没有重复成员的智能列表。</p>
<hr>
<p>SortedSet(zset)是Redis提供的一个非常特别的数据结构，一方面它等价于Java的数据结构Map&lt;String, Double&gt;，可以给每一个元素value赋予一个权重score，另一方面它又类似于TreeSet，内部的元素会按照权重score进行排序，可以得到每个元素的名次，还可以通过score的范围来获取元素的列表。</p>
<p>zset底层使用了两个数据结构</p>
<ul>
<li>hash，hash的作用就是关联元素value和权重score，保障元素value的唯一性，可以通过元素value找到相应的score值</li>
<li>跳跃表，跳跃表的目的在于给元素value排序，根据score的范围获取元素列表。</li>
</ul>
<hr>
<p>zadd  key score1 value1 score2 value2 将一个或多个 member 元素及其 score 值加入到有序集 key 当中。<br>zrange key start stop (WITHSCORES)  返回有序集 key 中，下标在start stop之间的元素  带WITHSCORES，可以让分数一起和值返回到结果集。</p>
<p>zrangebyscore key min max (withscores) (limit offset coun)   返回有序集 key 中，所有 score 值介于 min 和 max 之间(包括等于 min 或 max )的成员。有序集成员按 score 值递增(从小到大)次序排列。<br>zrevrangebyscore key max min (withscores) (limit offset coun) 同上，改为从大到小排列。</p>
<p>zincrby key increment value     为元素的score加上增量<br>zrem  key value  删除该集合下，指定值的元素<br>zcount key min max 统计该集合，分数区间内的元素个数<br>zrank key value  返回该值在集合中的排名，从0开始。</p>
<p>用zset实现一个文章访问量的排行榜</p>
<h6 id="跳跃表"><a href="#跳跃表" class="headerlink" title="跳跃表"></a>跳跃表</h6><p>跳跃表(跳表)<br>有序集合在生活中比较常见，例如根据成绩对学生排名，根据得分对玩家排名等。对于有序集合的底层实现，可以用数组、平衡树、链表等。数组不便元素的插入、删除；平衡树或红黑树虽然效率高但结构复杂；链表查询需要遍历所有效率低。Redis采用的是跳跃表。跳跃表效率堪比红黑树，实现远比红黑树简单。</p>
<p><img src="https://s1.328888.xyz/2022/08/09/07LkE.png" alt="续"></p>
<h3 id="Redis配置文件"><a href="#Redis配置文件" class="headerlink" title="Redis配置文件"></a>Redis配置文件</h3><p>pdf P26</p>
<h3 id="Redis的发布和订阅"><a href="#Redis的发布和订阅" class="headerlink" title="Redis的发布和订阅"></a>Redis的发布和订阅</h3><p>Redis 发布订阅 (pub/sub) 是一种消息通信模式：发送者 (pub) 发送消息，订阅者 (sub) 接收消息</p>
<p>Redis 客户端可以订阅任意数量的频道</p>
<p><img src="https://s1.328888.xyz/2022/08/09/07Elk.png" alt="续"></p>
<h3 id="新数据类型"><a href="#新数据类型" class="headerlink" title="新数据类型"></a>新数据类型</h3><p><strong>Bitmaps</strong></p>
<ul>
<li>Bitmaps本身不是一种数据类型， 实际上它就是字符串（key-value） ， 但是它可以对字符串的位进行操作。</li>
<li>Bitmaps单独提供了一套命令， 所以在Redis中使用Bitmaps和使用字符串的方法不太相同。 可以把Bitmaps想象成一个以位为单位的数组， 数组的每个单元只能存储0和1， 数组的下标在Bitmaps中叫做偏移量。</li>
</ul>
<p><strong>HyperLogLog</strong><br>在工作当中，我们经常会遇到与统计相关的功能需求，比如统计网站PV（PageView页面访问量）,可以使用Redis的incr、incrby轻松实现。<br>但像UV（UniqueVisitor，独立访客）、独立IP数、搜索记录数等需要去重和计数的问题如何解决？这种求集合中不重复元素个数的问题称为基数问题。</p>
<p>Redis HyperLogLog 是用来做基数统计的算法，HyperLogLog 的优点是，在输入元素的数量或者体积非常非常大时，计算基数所需的空间总是固定的、并且是很小的。<br>在 Redis 里面，每个 HyperLogLog 键只需要花费 12 KB 内存，就可以计算接近 2^64 个不同元素的基数。这和计算基数时，元素越多耗费内存就越多的集合形成鲜明对比。<br>但是，因为 HyperLogLog 只会根据输入元素来计算基数，而不会储存输入元素本身，所以 HyperLogLog 不能像集合那样，返回输入的各个元素。</p>
<p>什么是基数?<br>比如数据集 {1, 3, 5, 7, 5, 7, 8}， 那么这个数据集的基数集为 {1, 3, 5 ,7, 8}, 基数(不重复元素)为5。 基数估计就是在误差可接受的范围内，快速计算基数。</p>
<p><strong>Geospatial</strong></p>
<p>Redis 3.2 中增加了对GEO类型的支持。GEO，Geographic，地理信息的缩写。该类型，就是元素的2维坐标，在地图上就是经纬度。redis基于该类型，提供了经纬度设置，查询，范围查询，距离查询，经纬度Hash等常见操作。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#bind 127.0.0.1 -::1</span><br><span class="line">bind 0.0.0.0</span><br><span class="line"></span><br><span class="line">#protected-mode yes</span><br><span class="line">protected-mode no</span><br><span class="line"></span><br><span class="line">#daemonize no</span><br><span class="line">daemonize yes</span><br><span class="line"></span><br><span class="line">logfile &#x2F;url&#x2F;local&#x2F;bin&#x2F;redis-log.log</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="模拟验证码"><a href="#模拟验证码" class="headerlink" title="模拟验证码"></a>模拟验证码</h3><h3 id="springboot整合redis"><a href="#springboot整合redis" class="headerlink" title="springboot整合redis"></a>springboot整合redis</h3><h3 id="redis事务"><a href="#redis事务" class="headerlink" title="redis事务"></a>redis事务</h3><p>Redis事务是一个单独的隔离操作：事务中的所有命令都会序列化、按顺序地执行。事务在执行的过程中，不会被其他客户端发送来的命令请求所打断。<br>Redis事务的主要作用就是串联多个命令防止别的命令插队。</p>
<h4 id="事务操作"><a href="#事务操作" class="headerlink" title="事务操作"></a>事务操作</h4><p>从输入Multi命令开始，输入的命令都会依次进入命令队列中，但不会执行，直到输入Exec后，Redis会将之前的命令队列中的命令依次执行。<br>组队的过程中可以通过discard来放弃组队。<br><img src="https://s1.328888.xyz/2022/08/09/0zWom.png" alt="嗯"></p>
<h4 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h4><p>组队中某个命令出现了报告错误，执行时整个的所有队列都会被取消。</p>
<p>如果执行阶段某个命令报出了错误，则只有报错的命令不会被执行，而其他的命令都会执行，不会回滚。</p>
<h4 id="事务冲突"><a href="#事务冲突" class="headerlink" title="事务冲突"></a>事务冲突</h4><ul>
<li><p>悲观锁(Pessimistic Lock), 顾名思义，就是很悲观，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会block直到它拿到锁。传统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁。</p>
</li>
<li><p>乐观锁(Optimistic Lock), 顾名思义，就是很乐观，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号等机制。<strong>乐观锁适用于多读的应用类型，这样可以提高吞吐量。Redis就是利用这种check-and-set机制实现事务的。</strong></p>
</li>
</ul>
<p>抢票就是乐观锁</p>
<p><img src="https://s1.328888.xyz/2022/08/09/0zdS7.png" alt="p2"></p>
<p>watch<br>在执行multi之前，先执行watch key1 [key2],可以监视一个(或多个) key ，如果在事务执行之前这个(或这些) key 被其他命令所改动，那么事务将被打断。</p>
<p>unwatch<br>取消 WATCH 命令对所有 key 的监视。<br>如果在执行 WATCH 命令之后，EXEC 命令或DISCARD 命令先被执行了的话，那么就不需要再执行UNWATCH 了。</p>
<h5 id="Redis事务三特性"><a href="#Redis事务三特性" class="headerlink" title="Redis事务三特性"></a>Redis事务三特性</h5><ul>
<li>单独的隔离操作<ul>
<li>事务中的所有命令都会序列化、按顺序地执行。事务在执行的过程中，不会被其他客户端发送来的命令请求所打断。</li>
</ul>
</li>
<li>没有隔离级别的概念<ul>
<li>队列中的命令没有提交之前都不会实际被执行，因为事务提交前任何指令都不会被实际执行</li>
</ul>
</li>
<li>不保证原子性<ul>
<li>事务中如果有一条命令执行失败，其后的命令仍然会被执行，没有回滚</li>
</ul>
</li>
</ul>
<h4 id="秒杀案例"><a href="#秒杀案例" class="headerlink" title="秒杀案例"></a>秒杀案例</h4><p>商品库存  秒杀人员</p>
<h5 id="秒杀并发模拟"><a href="#秒杀并发模拟" class="headerlink" title="秒杀并发模拟"></a>秒杀并发模拟</h5><p>使用工具ab模拟测试 yum install httpd-tools</p>
<p>vim postfile 模拟表单提交参数,以&amp;符号结尾;存放当前目录。<br>内容：prodid=0101&amp;</p>
<p>ab -n 2000 -c 200 -k -p ~/postfile -T application/x-www-form-urlencoded <a target="_blank" rel="noopener" href="http://192.168.1.8:8081/Seckill/doseckill">http://192.168.1.8:8081/Seckill/doseckill</a></p>
<p>但会出现超卖现象(秒杀结束后，还会秒杀成功，库存边负数)</p>
<p>用乐观锁淘汰用户</p>
<p><img src="https://s1.328888.xyz/2022/08/09/0ziuK.png" alt="p2"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;增加乐观锁</span><br><span class="line">jedis.watch(qtkey);</span><br><span class="line"> </span><br><span class="line">&#x2F;&#x2F;3.判断库存</span><br><span class="line">String qtkeystr &#x3D; jedis.get(qtkey);</span><br><span class="line">if(qtkeystr&#x3D;&#x3D;null || &quot;&quot;.equals(qtkeystr.trim())) &#123;</span><br><span class="line">System.out.println(&quot;未初始化库存&quot;);</span><br><span class="line">jedis.close();</span><br><span class="line">return false ;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">int qt &#x3D; Integer.parseInt(qtkeystr);</span><br><span class="line">if(qt&lt;&#x3D;0) &#123;</span><br><span class="line">System.err.println(&quot;已经秒光&quot;);</span><br><span class="line">jedis.close();</span><br><span class="line">return false;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">&#x2F;&#x2F;增加事务</span><br><span class="line">Transaction multi &#x3D; jedis.multi();</span><br><span class="line"> </span><br><span class="line">&#x2F;&#x2F;4.减少库存</span><br><span class="line">&#x2F;&#x2F;jedis.decr(qtkey);</span><br><span class="line">multi.decr(qtkey);</span><br><span class="line"> </span><br><span class="line">&#x2F;&#x2F;5.加人</span><br><span class="line">&#x2F;&#x2F;jedis.sadd(usrkey, uid);</span><br><span class="line">multi.sadd(usrkey, uid);</span><br><span class="line"> </span><br><span class="line">&#x2F;&#x2F;执行事务</span><br><span class="line">List&lt;Object&gt; list &#x3D; multi.exec();</span><br><span class="line"> </span><br><span class="line">&#x2F;&#x2F;判断事务提交是否失败</span><br><span class="line">if(list&#x3D;&#x3D;null || list.size()&#x3D;&#x3D;0) &#123;</span><br><span class="line">System.out.println(&quot;秒杀失败&quot;);</span><br><span class="line">jedis.close();</span><br><span class="line">return false;</span><br><span class="line">&#125;</span><br><span class="line">System.err.println(&quot;秒杀成功&quot;);</span><br><span class="line">jedis.close();</span><br></pre></td></tr></table></figure>

<h5 id="继续增加并发测试"><a href="#继续增加并发测试" class="headerlink" title="继续增加并发测试"></a>继续增加并发测试</h5><p>ab -n 2000 -c 200 -k -p postfile -T ‘application/x-www-form-urlencoded’ <a target="_blank" rel="noopener" href="http://192.168.140.1:8080/seckill/doseckill">http://192.168.140.1:8080/seckill/doseckill</a></p>
<p>增加-r参数，-r   Don’t exit on socket receive errors.<br>ab -n 2000 -c 100 -r -p postfile -T ‘application/x-www-form-urlencoded’ <a target="_blank" rel="noopener" href="http://192.168.140.1:8080/seckill/doseckill">http://192.168.140.1:8080/seckill/doseckill</a></p>
<ul>
<li>已经秒光可是还有库存<br>ab -n 2000 -c 100 -p postfile -T ‘application/x-www-form-urlencoded’ <a target="_blank" rel="noopener" href="http://192.168.137.1:8080/seckill/doseckill">http://192.168.137.1:8080/seckill/doseckill</a></li>
</ul>
<p>已经秒光，可是还有库存。原因，就是乐观锁导致很多请求都失败。先点的没秒到，后点的可能秒到了。</p>
<p>连接超时，通过连接池解决</p>
<ul>
<li><p>连接池<br>节省每次连接redis服务带来的消耗，把连接好的实例反复利用。<br>通过参数管理连接的行为<br>JedisPoolUtil.java</p>
</li>
<li><p>链接池参数</p>
<ul>
<li>MaxTotal：控制一个pool可分配多少个jedis实例，通过pool.getResource()来获取；如果赋值为-1，则表示不限制；如果pool已经分配了MaxTotal个jedis实例，则此时pool的状态为exhausted。</li>
<li>maxIdle：控制一个pool最多有多少个状态为idle(空闲)的jedis实例；</li>
<li>MaxWaitMillis：表示当borrow一个jedis实例时，最大的等待毫秒数，如果超过等待时间，则直接抛JedisConnectionException；</li>
<li>testOnBorrow：获得一个jedis实例的时候是否检查连接可用性（ping()）；如果为true，则得到的jedis实例均是可用的；</li>
</ul>
</li>
</ul>
<h5 id="解决库存遗留问题"><a href="#解决库存遗留问题" class="headerlink" title="解决库存遗留问题"></a>解决库存遗留问题</h5><h6 id="LUA脚本"><a href="#LUA脚本" class="headerlink" title="LUA脚本"></a>LUA脚本</h6><p>Lua 是一个小巧的脚本语言，Lua脚本可以很容易的被C/C++ 代码调用，也可以反过来调用C/C++的函数，Lua并没有提供强大的库，一个完整的Lua解释器不过200k，所以Lua不适合作为开发独立应用程序的语言，而是作为嵌入式脚本语言。<br>很多应用程序、游戏使用LUA作为自己的嵌入式脚本语言，以此来实现可配置性、可扩展性。<br>这其中包括魔兽争霸地图、魔兽世界、博德之门、愤怒的小鸟等众多游戏插件或外挂。<br><a target="_blank" rel="noopener" href="https://www.w3cschool.cn/lua/">https://www.w3cschool.cn/lua/</a></p>
<h6 id="脚本的优势"><a href="#脚本的优势" class="headerlink" title="脚本的优势"></a>脚本的优势</h6><p>将复杂的或者多步的redis操作，写为一个脚本，一次提交给redis执行，减少反复连接redis的次数。提升性能。</p>
<p>LUA脚本是类似redis事务，有一定的原子性，不会被其他命令插队，可以完成一些redis事务性的操作。</p>
<p>但是注意redis的lua脚本功能，只有在Redis 2.6以上的版本才可以使用。</p>
<p>利用lua脚本淘汰用户，解决超卖问题。<br>redis 2.6版本以后，通过lua脚本解决<strong>争抢问题</strong>，实际上是<strong>redis 利用其单线程的特性，用任务队列的方式解决多任务并发问题。</strong></p>
<h3 id="持久化"><a href="#持久化" class="headerlink" title="持久化"></a>持久化</h3><h4 id="RDB"><a href="#RDB" class="headerlink" title="RDB"></a>RDB</h4><p>RDB（Redis DataBase）<br>在指定的时间间隔内将内存中的数据集快照写入磁盘， 也就是行话讲的Snapshot快照，它恢复时是将快照文件直接读到内存里</p>
<hr>
<p>Redis会单独创建（fork）一个子进程来进行持久化，会先将数据写入到 一个临时文件中，待持久化过程都结束了，再用这个临时文件替换上次持久化好的文件。 整个过程中，主进程是不进行任何IO操作的，这就确保了极高的性能 如果需要进行大规模数据的恢复，且对于数据恢复的完整性不是非常敏感，那RDB方式要比AOF方式更加的高效。RDB的缺点是<strong>最后一次持久化后的数据可能丢失。</strong> </p>
<hr>
<h5 id="Fork"><a href="#Fork" class="headerlink" title="Fork"></a>Fork</h5><ul>
<li>Fork的作用是复制一个与当前进程一样的进程。新进程的所有数据（变量、环境变量、程序计数器等） 数值都和原进程一致，但是是一个全新的进程，并作为原进程的子进程</li>
<li>在Linux程序中，fork()会产生一个和父进程完全相同的子进程，但子进程在此后多会exec系统调用，出于效率考虑，Linux中引入了<strong>写时复制技术”</strong></li>
<li>一般情况父进程和子进程会共用同一段物理内存，只有进程空间的各段的内容要发生变化时，才会将父进程的内容复制一份给子进程。</li>
</ul>
<p><img src="https://gitee.com/regulus25/markdown-picture/raw/master/Redis%E5%9B%BE%E7%89%87/202202121637.png" alt="RDB流程"></p>
<h6 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h6><ul>
<li>适合大规模的数据恢复</li>
<li>对数据完整性和一致性要求不高更适合使用</li>
<li>节省磁盘空间</li>
<li>恢复速度快</li>
</ul>
<h6 id="劣势"><a href="#劣势" class="headerlink" title="劣势"></a>劣势</h6><ul>
<li>Fork的时候，内存中的数据被克隆了一份，大致2倍的膨胀性需要考虑</li>
<li>虽然Redis在fork时使用了写时拷贝技术,但是如果数据庞大时还是比较消耗性能。</li>
<li>在备份周期在一定间隔时间做一次备份，所以如果Redis意外down掉的话，就会丢失最后一次快照后的所有修改。</li>
</ul>
<p><img src="https://s1.328888.xyz/2022/08/09/0zAPj.png" alt="rdb备份"></p>
<h4 id="AOF"><a href="#AOF" class="headerlink" title="AOF"></a>AOF</h4><p>AOF（Append Only File）</p>
<p><strong>以日志的形式来记录每个写操作（增量保存）</strong>，将Redis执行过的所有写指令记录下来(<strong>读操作不记录</strong>)， <strong>只许追加文件但不可以改写文件</strong>，redis启动之初会读取该文件重新构建数据，换言之，redis 重启的话就根据日志文件的内容将写指令从前到后执行一次以完成数据的恢复工作</p>
<p>需要修改配置文件<br>appendonly yes<br><em>AOF和RDB同时开启，系统默认取AOF的数据（数据不会存在丢失）</em></p>
<h5 id="AOF启动-修复-恢复"><a href="#AOF启动-修复-恢复" class="headerlink" title="AOF启动/修复/恢复"></a>AOF启动/修复/恢复</h5><ul>
<li>AOF的备份机制和性能虽然和RDB不同, 但是备份和恢复的操作同RDB一样，都是拷贝备份文件，需要恢复时再拷贝到Redis工作目录下，启动系统即加载。</li>
<li>正常恢复<ul>
<li>修改默认的appendonly no，改为yes</li>
<li>将有数据的aof文件复制一份保存到对应目录(查看目录：config get dir)</li>
<li>恢复：重启redis然后重新加载</li>
</ul>
</li>
<li>异常恢复<ul>
<li>修改默认的appendonly no，改为yes</li>
<li>如遇到AOF文件损坏，通过/usr/local/bin/redis-check-aof–fix appendonly.aof进行恢复</li>
<li>备份被写坏的AOF文件</li>
<li>恢复：重启redis，然后重新加载</li>
</ul>
</li>
</ul>
<h5 id="Rewrite压缩"><a href="#Rewrite压缩" class="headerlink" title="Rewrite压缩"></a>Rewrite压缩</h5><p>AOF采用文件追加方式，文件会越来越大为避免出现此种情况，新增了重写机制, 当AOF文件的大小超过所设定的阈值时，Redis就会启动AOF文件的内容压缩， 只保留可以恢复数据的最小指令集.可以使用命令bgrewriteaof</p>
<p>AOF文件持续增长而过大时，会fork出一条新进程来将文件重写(也是先写临时文件最后再rename)，<strong>redis4.0版本后的重写，是指上就是把rdb 的快照，以二级制的形式附在新的aof头部，作为已有的历史数据，替换掉原来的流水账操作。</strong></p>
<p>no-appendfsync-on-rewrite：</p>
<p>如果 no-appendfsync-on-rewrite=yes ,不写入aof文件只写入缓存，用户请求不会阻塞，但是在这段时间如果宕机会丢失这段时间的缓存数据。（降低数据安全性，提高性能）</p>
<p>如果 no-appendfsync-on-rewrite=no,  还是会把数据往磁盘里刷，但是遇到重写操作，可能会发生阻塞。（数据安全，但是性能降低）</p>
<p><strong>触发机制，何时重写</strong></p>
<p>Redis会记录上次重写时的AOF大小，默认配置是当AOF文件大小是上次rewrite后大小的一倍且文件大于64M时触发</p>
<p>重写虽然可以节约大量磁盘空间，减少恢复时间。但是每次重写还是有一定的负担的，因此设定Redis要满足一定条件才会进行重写。</p>
<p>auto-aof-rewrite-percentage：设置重写的基准值，文件达到100%时开始重写（文件是原来重写后文件的2倍时触发）</p>
<p>auto-aof-rewrite-min-size：设置重写的基准值，最小文件64MB。达到这个值开始重写。</p>
<p>例如：文件达到70MB开始重写，降到50MB，下次什么时候开始重写？100MB<br>系统载入时或者上次重写完毕时，Redis会记录此时AOF大小，设为base_size,<br>如果Redis的AOF当前大小&gt;= base_size +base_size*100% (默认)且当前大小&gt;=64mb(默认)的情况下，Redis会对AOF进行重写。</p>
<h6 id="重写流程"><a href="#重写流程" class="headerlink" title="重写流程"></a>重写流程</h6><ul>
<li>bgrewriteaof触发重写，判断是否当前有bgsave或bgrewriteaof在运行，如果有，则等待该命令结束后再继续执行。</li>
<li>主进程fork出子进程执行重写操作，保证主进程不会阻塞。</li>
<li>子进程遍历redis内存中数据到临时文件，客户端的写请求同时写入aof_buf缓冲区和aof_rewrite_buf重写缓冲区保证原AOF文件完整以及新AOF文件生成期间的新的数据修改动作不会丢失。</li>
<li>子进程写完新的AOF文件后，向主进程发信号，父进程更新统计信息。 主进程把aof_rewrite_buf中的数据写入到新的AOF文件。</li>
<li>使用新的AOF文件覆盖旧的AOF文件，完成AOF重写。</li>
</ul>
<p>备份机制更稳健，丢失数据概率更低。<br>可读的日志文本，通过操作AOF稳健，可以处理误操作。</p>
<p>比起RDB占用更多的磁盘空间。<br>恢复备份速度要慢。<br>每次读写都同步的话，有一定的性能压力。<br>存在个别Bug，造成恢复不能。</p>
<h3 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h3><p>主机数据更新后根据配置和策略， 自动同步到备机的master/slaver机制，Master以写为主，Slave以读为主<br><img src="https://s1.328888.xyz/2022/08/09/0zn3I.png" alt="p3"></p>
<p><img src="https://s1.328888.xyz/2022/08/09/0zXiX.png" alt="p4"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> JedisSentinelPool jedisSentinelPool=<span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span>  Jedis <span class="title">getJedisFromSentinel</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(jedisSentinelPool==<span class="keyword">null</span>)&#123;</span><br><span class="line">    Set&lt;String&gt; sentinelSet=<span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    sentinelSet.add(<span class="string">&quot;192.168.11.103:26379&quot;</span>);</span><br><span class="line"></span><br><span class="line">    JedisPoolConfig jedisPoolConfig =<span class="keyword">new</span> JedisPoolConfig();</span><br><span class="line">    jedisPoolConfig.setMaxTotal(<span class="number">10</span>); <span class="comment">//最大可用连接数</span></span><br><span class="line">    jedisPoolConfig.setMaxIdle(<span class="number">5</span>); <span class="comment">//最大闲置连接数</span></span><br><span class="line">    jedisPoolConfig.setMinIdle(<span class="number">5</span>); <span class="comment">//最小闲置连接数</span></span><br><span class="line">    jedisPoolConfig.setBlockWhenExhausted(<span class="keyword">true</span>); <span class="comment">//连接耗尽是否等待</span></span><br><span class="line">    jedisPoolConfig.setMaxWaitMillis(<span class="number">2000</span>); <span class="comment">//等待时间</span></span><br><span class="line">    jedisPoolConfig.setTestOnBorrow(<span class="keyword">true</span>); <span class="comment">//取连接的时候进行一下测试 ping pong</span></span><br><span class="line"></span><br><span class="line">    jedisSentinelPool=<span class="keyword">new</span> JedisSentinelPool(<span class="string">&quot;mymaster&quot;</span>,sentinelSet,jedisPoolConfig);</span><br><span class="line">    <span class="keyword">return</span> jedisSentinelPool.getResource();</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> jedisSentinelPool.getResource();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="薪火相传"><a href="#薪火相传" class="headerlink" title="薪火相传"></a>薪火相传</h4><p>类比二叉树了属于是<br>上一个Slave可以是下一个slave的Master，Slave同样可以接收其他 slaves的连接和同步请求，那么该slave作为了链条中下一个的master, 可以有效减轻master的写压力,<strong>去中心化</strong>降低风险。</p>
<p>用 slaveof  ip port<br>中途变更转向:会清除之前的数据，重新建立拷贝最新的<br>风险是一旦某个slave宕机，后面的slave都没法备份<br>主机挂了，从机还是从机，无法写数据了</p>
<h4 id="反客为主"><a href="#反客为主" class="headerlink" title="反客为主"></a>反客为主</h4><p>当一个master宕机后，后面的slave可以立刻升为master，其后面的slave不用做任何修改。<br>用 slaveof  no one  将从机变为主机。</p>
<h4 id="复制原理"><a href="#复制原理" class="headerlink" title="复制原理"></a>复制原理</h4><p><img src="https://s1.328888.xyz/2022/08/09/0zpaP.png" alt="p5"></p>
<h4 id="哨兵模式"><a href="#哨兵模式" class="headerlink" title="哨兵模式"></a>哨兵模式</h4><p><strong>反客为主</strong>的自动版，能够后台监控主机是否故障，如果故障了根据投票数自动将从库转换为主库</p>
<ul>
<li>先一主二仆模式<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">info replication</span><br><span class="line"></span><br><span class="line"># 在自定义的&#x2F;myredis目录下，新建sentinel.conf，名字不能错</span><br><span class="line">sentinel monitor mymaster 0.0.0.0 6379 1</span><br><span class="line"># 其中mymaster为监控对象起的服务器名称， 1 为至少有多少个哨兵同意迁移的数量。 </span><br><span class="line"></span><br><span class="line">redis-sentinel sentinel.conf</span><br><span class="line"></span><br><span class="line"># 当主机挂掉，从机选举中产生新的主机</span><br><span class="line">  (大概10秒左右可以看到哨兵窗口日志，切换了新的主机)</span><br><span class="line">哪个从机会被选举为主机呢？根据优先级别：slave-priority </span><br><span class="line">原主机重启后会变为从机。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

</li>
</ul>
<p><strong>缺点</strong> 复制延时</p>
<p>由于所有的写操作都是先在Master上操作，然后同步更新到Slave上，<br>所以从Master同步到Slave机器有一定的延迟，<br>当系统很繁忙的时候，延迟问题会更加严重，<br>Slave机器数量的增加也会使这个问题更加严重。</p>
<h4 id="故障恢复"><a href="#故障恢复" class="headerlink" title="故障恢复"></a>故障恢复</h4><p><img src="https://s1.328888.xyz/2022/08/09/0zHNR.png" alt="p6"></p>
<h3 id="集群"><a href="#集群" class="headerlink" title="集群"></a>集群</h3><p>容量不够，redis如何进行扩容？<br>并发写操作， redis如何分摊？<br><strong>另外，主从模式，薪火相传模式，主机宕机，导致ip地址发生变化，应用程序中配置需要修改对应的主机地址、端口等信息。</strong><br>之前通过代理主机来解决，但是<strong>redis3.0</strong>中提供了解决方案。就是<strong>无中心化集群</strong>配置。</p>
<p>Redis 集群实现了对Redis的水平扩容，即启动N个redis节点，将整个数据库分布存储在这N个节点中，每个节点存储总数据的1/N。<br>Redis 集群通过分区（partition）来提供一定程度的可用性（availability）： 即使集群中有一部分节点失效或者无法进行通讯， 集群也可以继续处理命令请求。</p>
<h4 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h4><p>删除持久化数据<br>将rdb,aof文件都删除掉。</p>
<p>开启daemonize yes<br>Pid文件名字<br>指定端口<br>Log文件名字<br>Dump.rdb名字<br>Appendonly 关掉或者换名字</p>
<p>cluster-enabled yes    打开集群模式<br>cluster-config-file nodes-6379.conf  设定节点配置文件名<br>cluster-node-timeout 15000   设定节点失联时间，超过该时间（毫秒），集群自动进行主从切换。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">include &#x2F;home&#x2F;bigdata&#x2F;redis.conf</span><br><span class="line">port 6379</span><br><span class="line">pidfile &quot;&#x2F;var&#x2F;run&#x2F;redis_6379.pid&quot;</span><br><span class="line">dbfilename &quot;dump6379.rdb&quot;</span><br><span class="line"></span><br><span class="line"># dir &quot;&#x2F;home&#x2F;bigdata&#x2F;redis_cluster&quot;</span><br><span class="line"># logfile &quot;&#x2F;home&#x2F;bigdata&#x2F;redis_cluster&#x2F;redis_err_6379.log&quot;</span><br><span class="line"></span><br><span class="line">cluster-enabled yes</span><br><span class="line">cluster-config-file nodes-6379.conf</span><br><span class="line">cluster-node-timeout 15000</span><br></pre></td></tr></table></figure>

<p>使用查找替换修改另外5个文件<br>启动6个redis</p>
<p>将六个节点合成一个集群<br>组合之前，请确保所有redis实例启动后，nodes-xxxx.conf文件都生成正常。</p>
<p>cd  /opt/redis-6.2.1/src</p>
<p>–replicas 1 采用最简单的方式配置集群，一台主机，一台从机，正好三组。</p>
<p>redis-cli –cluster create –cluster-replicas 1 192.168.11.101:6379 192.168.11.101:6380 192.168.11.101:6381 192.168.11.101:6389 192.168.11.101:6390 192.168.11.101:6391</p>
<p>可能直接进入读主机，存储数据时，会出现MOVED重定向操作。所以，应该以集群方式登录。</p>
<p>redis-cli -c -p 6379 采用集群策略连接，设置数据会自动切换到相应的写主机</p>
<ul>
<li>通过 cluster nodes 命令查看集群信息</li>
</ul>
<p>一个集群至少要有三个主节点。<br>选项 –cluster-replicas 1 表示我们希望为集群中的每个主节点创建一个从节点。<br>分配原则尽量保证每个主数据库运行在不同的IP地址，每个从库和主库不在一个IP地址上。</p>
<ul>
<li>什么是slots(插槽)</li>
</ul>
<p>[OK] All 16384 slots covered.<br>一个 Redis 集群包含 16384 个插槽（hash slot）， 数据库中的每个键都属于这 16384 个插槽的其中一个，<br>集群使用公式 CRC16(key) % 16384 来计算键 key 属于哪个槽， 其中 CRC16(key) 语句用于计算键 key 的 CRC16 校验和 。<br>集群中的每个节点负责处理一部分插槽。 举个例子， 如果一个集群可以有主节点， 其中：<br>节点 A 负责处理 0 号至 5460 号插槽。<br>节点 B 负责处理 5461 号至 10922 号插槽。<br>节点 C 负责处理 10923 号至 16383 号插槽。</p>
<ul>
<li>在集群中录入值</li>
</ul>
<p>在redis-cli每次录入、查询键值，redis都会计算出该key应该送往的插槽，如果不是该客户端对应服务器的插槽，redis会报错，并告知应前往的redis实例地址和端口。<br>redis-cli客户端提供了 –c 参数实现自动重定向。<br>如 redis-cli  -c –p 6379 登入后，再录入、查询键值对可以自动重定向。<br>不在一个slot下的键值，是不能使用mget,mset等多键操作。<br>可以通过{}来定义组的概念，从而使key中{}内相同内容的键值对放到一个slot中去。</p>
<ul>
<li>查询集群中的值<br>CLUSTER GETKEYSINSLOT slot count 返回 count 个 slot 槽中的键。</li>
</ul>
<p>显然，集群中自动设置了哨兵</p>
<ul>
<li>故障恢复<br>如果某一段插槽的主从都挂掉，而cluster-require-full-coverage 为yes ，那么 ，整个集群都挂掉<br>如果某一段插槽的主从都挂掉，而cluster-require-full-coverage 为no ，那么，该插槽数据全都不能使用，也无法存储。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JedisClusterTest</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123; </span><br><span class="line">     Set&lt;HostAndPort&gt;set =<span class="keyword">new</span> HashSet&lt;HostAndPort&gt;();</span><br><span class="line">     set.add(<span class="keyword">new</span> HostAndPort(<span class="string">&quot;192.168.31.211&quot;</span>,<span class="number">6379</span>));</span><br><span class="line">     JedisCluster jedisCluster=<span class="keyword">new</span> JedisCluster(set);</span><br><span class="line">     jedisCluster.set(<span class="string">&quot;k1&quot;</span>, <span class="string">&quot;v1&quot;</span>);</span><br><span class="line">     System.out.println(jedisCluster.get(<span class="string">&quot;k1&quot;</span>));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><p>实现扩容<br>分摊压力<br>无中心配置相对简单</p>
<h4 id="不足"><a href="#不足" class="headerlink" title="不足"></a>不足</h4><p>多键操作是不被支持的<br>多键的Redis事务是不被支持的。lua脚本不被支持<br>由于集群方案出现较晚，很多公司已经采用了其他的集群方案，而代理或者客户端分片的方案想要迁移至redis cluster，需要整体迁移而不是逐步过渡，复杂度较大。</p>
<h3 id="应用问题"><a href="#应用问题" class="headerlink" title="应用问题"></a>应用问题</h3><p><strong>缓存处理流程</strong><br>前台请求，后台先从缓存中取数据，取到直接返回结果，取不到时从数据库中取，数据库取到更新缓存，并返回结果，数据库也没取到，那直接返回空结果。</p>
<h4 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h4><p>key对应的数据在数据源并不存在，每次针对此key的请求从缓存获取不到，请求都会压到数据源，从而可能压垮数据源。比如用一个不存在的用户id获取用户信息，不论缓存还是数据库都没有，若黑客利用此漏洞进行攻击可能压垮数据库。</p>
<p>1.应用服务器压力变大了<br>2.Redis命中率降低<br>3.一直查询数据库</p>
<p>1.Redis查询不到数据<br>2.出现很多非正常url访问</p>
<p>解决方案</p>
<ul>
<li>对空值缓存：如果一个查询返回的数据为空（不管是数据是否不存在），我们仍然把这个空结果（null）进行缓存，设置空结果的过期时间会很短，最长不超过五分钟</li>
<li>设置可访问的名单（白名单）：<br>使用bitmaps类型定义一个可以访问的名单，名单id作为bitmaps的偏移量，每次访问和bitmap里面的id进行比较，如果访问id不在bitmaps里面，进行拦截，不允许访问。</li>
<li>采用布隆过滤器：(布隆过滤器（Bloom Filter）是1970年由布隆提出的。它实际上是一个很长的二进制向量(位图)和一系列随机映射函数（哈希函数）。<br>布隆过滤器可以用于检索一个元素是否在一个集合中。它的优点是空间效率和查询时间都远远超过一般的算法，缺点是有一定的误识别率和删除困难。)<br>将所有可能存在的数据哈希到一个足够大的bitmaps中，一个一定不存在的数据会被 这个bitmaps拦截掉，从而避免了对底层存储系统的查询压力。</li>
<li>进行实时监控：当发现Redis的命中率开始急速降低，需要排查访问对象和访问的数据，和运维人员配合，可以设置黑名单限制服务</li>
</ul>
<h4 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h4><p>1.数据库访问压力瞬间增大<br>2.Redis里面没有出现大量key过期<br>3.redis正常运行</p>
<p>1.redis某个key过期了，大量访问使用这个key</p>
<p>key可能会在某些时间点被超高并发地访问，是一种非常“热点”的数据。这个时候，需要考虑一个问题：缓存被“击穿”的问题。</p>
<ul>
<li>预先设置热门数据：在redis高峰访问之前，把一些热门数据提前存入到redis里面，加大这些热门数据key的时长</li>
<li>实时调整：现场监控哪些数据热门，实时调整key的过期时长</li>
<li>使用锁：<ul>
<li>就是在缓存失效的时候（判断拿出来的值为空），不是立即去load db。</li>
<li>先使用缓存工具的某些带成功操作返回值的操作（比如Redis的SETNX）去set一个mutex key</li>
<li>当操作返回成功时，再进行load db的操作，并回设缓存,最后删除mutex key；</li>
<li>当操作返回失败，证明有线程在load db，当前线程睡眠一段时间再重试整个get缓存的方法。<br><img src="https://s1.328888.xyz/2022/08/09/0zeSB.png" alt="p14"></li>
</ul>
</li>
</ul>
<h4 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h4><p>key对应的数据存在，但在redis中过期，此时若有大量并发请求过来，这些请求发现缓存过期一般都会从后端DB加载数据并回设到缓存，这个时候大并发的请求可能会瞬间把后端DB压垮。<br>缓存雪崩与缓存击穿的区别在于这里针对很多key缓存，前者则是某一个key</p>
<p>1.数据库压力变大  服务器崩溃</p>
<p>1.在极少时间段，查询大量key的集中过期情况</p>
<p>缓存失效时的雪崩效应对底层系统的冲击非常可怕！<br>解决方案：</p>
<ul>
<li>构建多级缓存架构：nginx缓存 + redis缓存 +其他缓存（ehcache等）</li>
<li>使用锁或队列：<br>用加锁或者队列的方式保证来保证不会有大量的线程对数据库一次性进行读写，从而避免失效时大量的并发请求落到底层存储系统上。不适用高并发情况</li>
<li>设置过期标志更新缓存：<br>记录缓存数据是否过期（设置提前量），如果过期会触发通知另外的线程在后台去更新实际key的缓存。</li>
<li>将缓存失效时间分散开：<br>比如我们可以在原有的失效时间基础上增加一个随机值，比如1-5分钟随机，这样每一个缓存的过期时间的重复率就会降低，就很难引发集体失效的事件。</li>
</ul>
<h4 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h4><p>随着业务发展的需要，原单体单机部署的系统被演化成分布式集群系统后，由于分布式系统多线程、多进程并且分布在不同机器上，这将使原单机部署情况下的并发控制锁策略失效，单纯的Java API并不能提供分布式锁的能力。为了解决这个问题就需要一种跨JVM的互斥机制来控制共享资源的访问，这就是分布式锁要解决的问题！</p>
<p>分布式锁主流的实现方案：</p>
<ol>
<li>基于数据库实现分布式锁</li>
<li>基于缓存（Redis等）</li>
<li>基于Zookeeper</li>
</ol>
<p>每一种分布式锁解决方案都有各自的优缺点：</p>
<ol>
<li>性能：redis最高</li>
<li>可靠性：zookeeper最高</li>
</ol>
<p>这里，我们就基于redis实现分布式锁。</p>
<p>redis:命令</p>
<p>set sku:1:info “OK” NX PX 10000<br>EX second ：设置键的过期时间为 second 秒。 SET key value EX second 效果等同于 SETEX key second value 。<br>PX millisecond ：设置键的过期时间为 millisecond 毫秒。 SET key value PX millisecond 效果等同于 PSETEX key millisecond value 。<br>NX ：只在键不存在时，才对键进行设置操作。 SET key value NX 效果等同于 SETNX key value 。<br>XX ：只在键已经存在时，才对键进行设置操作。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1.sernx 上锁 del释放锁</span><br><span class="line">2.锁一直没有释放，设置过期时间，自动释放</span><br><span class="line">3.上锁之后突然出现异常，无法设置过期时间</span><br><span class="line">set uesrs 10 nx ex 12  #上锁时候设置过期时间</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;testLock&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testLock</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//1获取锁，setne</span></span><br><span class="line">    Boolean lock = redisTemplate.opsForValue().setIfAbsent(<span class="string">&quot;lock&quot;</span>, <span class="string">&quot;111&quot;</span>);</span><br><span class="line">    <span class="comment">//setIfAbsent(&quot;lock&quot;, &quot;111&quot;,3,TimeUnit.SECONDS);</span></span><br><span class="line">    <span class="comment">//2获取锁成功、查询num的值</span></span><br><span class="line">    <span class="keyword">if</span>(lock)&#123;</span><br><span class="line">        Object value = redisTemplate.opsForValue().get(<span class="string">&quot;num&quot;</span>);</span><br><span class="line">        <span class="comment">//2.1判断num为空return</span></span><br><span class="line">        <span class="keyword">if</span>(StringUtils.isEmpty(value))&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//2.2有值就转成成int</span></span><br><span class="line">        <span class="keyword">int</span> num = Integer.parseInt(value+<span class="string">&quot;&quot;</span>);</span><br><span class="line">        <span class="comment">//2.3把redis的num加1</span></span><br><span class="line">        redisTemplate.opsForValue().set(<span class="string">&quot;num&quot;</span>, ++num);</span><br><span class="line">        <span class="comment">//2.4释放锁，del</span></span><br><span class="line">        redisTemplate.delete(<span class="string">&quot;lock&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">//3获取锁失败、每隔0.1秒再获取</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">100</span>);</span><br><span class="line">            testLock();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ab测试</p>
<p>场景：如果业务逻辑的执行时间是7s。执行流程如下</p>
<ol>
<li>index1业务逻辑没执行完，3秒后锁被自动释放。</li>
<li>index2获取到锁，执行业务逻辑，3秒后锁被自动释放。</li>
<li>index3获取到锁，执行业务逻辑</li>
<li>index1业务逻辑执行完成，开始调用del释放锁，这时释放的是index3的锁，导致index3的业务只执行1s就被别人释放。<br>最终等于没锁的情况。</li>
</ol>
<h4 id="管道技术"><a href="#管道技术" class="headerlink" title="管道技术"></a>管道技术</h4><p>Pipelining</p>
<p>Redis客户端与服务器之间使用TCP协议进行通信，并且很早就支持管道（pipelining）技术了。在某些高并发的场景下，网络开销成了Redis速度的瓶颈，所以需要使用管道技术来实现突破。</p>
<p>在介绍管道之前，先来想一下单条命令的执行步骤：</p>
<p>客户端把命令发送到服务器，然后阻塞客户端，等待着从socket读取服务器的返回结果<br>服务器处理命令并将结果返回给客户端<br>按照这样的描述，每个命令的执行时间 = 客户端发送时间+服务器处理和返回时间+一个网络来回的时间</p>
<p>其中一个网络来回的时间是不固定的，它的决定因素有很多，比如客户端到服务器要经过多少跳，网络是否拥堵等等。但是这个时间的量级也是最大的，也就是说一个命令的完成时间的长度很大程度上取决于网络开销。如果我们的服务器每秒可以处理10万条请求，而网络开销是250毫秒，那么实际上每秒钟只能处理4个请求。最暴力的优化方法就是使客户端和服务器在一台物理机上，这样就可以将网络开销降低到1ms以下。但是实际的生产环境我们并不会这样做。而且即使使用这种方法，当请求非常频繁时，这个时间和服务器处理时间比较仍然是很长的。</p>
<hr>
<p>为了解决这种问题，Redis在很早就支持了管道技术。也就是说客户端可以一次发送多条命令，不用逐条等待命令的返回值，而是到最后一起读取返回结果，这样只需要一次网络开销，速度就会得到明显的提升。管道技术其实已经非常成熟并且得到广泛应用了，例如POP3协议由于支持管道技术，从而显著提高了从服务器下载邮件的速度。</p>
<p>在Redis中，如果客户端使用管道发送了多条命令，那么服务器就会将多条命令放入一个队列中，这一操作会消耗一定的内存，所以管道中命令的数量并不是越大越好（太大容易撑爆内存），而是应该有一个合理的值。</p>
<ul>
<li>客户端进程调用write()把消息写入到操作系统内核为Socket分配的send buffer中</li>
<li>操作系统会把send buffer中的内容写入网卡，网卡再通过网关路由把内容发送到服务器端的网卡</li>
<li>服务端网卡会把接收到的消息写入操作系统为Socket分配的recv buffer</li>
<li>服务器进程调用read()读取消息然后进行处理</li>
<li>处理完成后调用write()把返回结果写入到服务器端的send buffer</li>
<li>服务器操作系统再将send buffer中的内容写入网卡，然后发送到客户端</li>
<li>客户端操作系统将网卡内容读到recv buffer中</li>
<li>客户端进程调用read()从recv buffer中读取消息并返回</li>
</ul>
<p>使用管道技术可以显著提升Redis处理命令的速度，其原理就是将多条命令打包，只需要一次网络开销，在服务器端和客户端各一次read()和write()系统调用，以此来节约时间。<br>管道中的命令数量要适当，并不是越多越好。<br>Redis2.6版本以后，脚本在大部分场景中的表现要优于管道。</p>
 
      <!-- reward -->
      
      <div id="reword-out">
        <div id="reward-btn">
          Donate
        </div>
      </div>
      
    </div>
    

    <!-- copyright -->
    
    <div class="declare">
      <ul class="post-copyright">
        <li>
          <i class="ri-copyright-line"></i>
          <strong>Copyright： </strong>
          
          Copyright is owned by the author. For commercial reprints, please contact the author for authorization. For non-commercial reprints, please indicate the source.
          
        </li>
      </ul>
    </div>
    
    <footer class="article-footer">
       
<div class="share-btn">
      <span class="share-sns share-outer">
        <i class="ri-share-forward-line"></i>
        分享
      </span>
      <div class="share-wrap">
        <i class="arrow"></i>
        <div class="share-icons">
          
          <a class="weibo share-sns" href="javascript:;" data-type="weibo">
            <i class="ri-weibo-fill"></i>
          </a>
          <a class="weixin share-sns wxFab" href="javascript:;" data-type="weixin">
            <i class="ri-wechat-fill"></i>
          </a>
          <a class="qq share-sns" href="javascript:;" data-type="qq">
            <i class="ri-qq-fill"></i>
          </a>
          <a class="douban share-sns" href="javascript:;" data-type="douban">
            <i class="ri-douban-line"></i>
          </a>
          <!-- <a class="qzone share-sns" href="javascript:;" data-type="qzone">
            <i class="icon icon-qzone"></i>
          </a> -->
          
          <a class="facebook share-sns" href="javascript:;" data-type="facebook">
            <i class="ri-facebook-circle-fill"></i>
          </a>
          <a class="twitter share-sns" href="javascript:;" data-type="twitter">
            <i class="ri-twitter-fill"></i>
          </a>
          <a class="google share-sns" href="javascript:;" data-type="google">
            <i class="ri-google-fill"></i>
          </a>
        </div>
      </div>
</div>

<div class="wx-share-modal">
    <a class="modal-close" href="javascript:;"><i class="ri-close-circle-line"></i></a>
    <p>扫一扫，分享到微信</p>
    <div class="wx-qrcode">
      <img src="//api.qrserver.com/v1/create-qr-code/?size=150x150&data=http://example.com/2022/01/29/redis6/" alt="微信分享二维码">
    </div>
</div>

<div id="share-mask"></div>  
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/" rel="tag">数据库</a></li></ul>

    </footer>
  </div>

   
  <nav class="article-nav">
    
      <a href="/2022/02/23/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/" class="article-nav-link">
        <strong class="article-nav-caption">上一篇</strong>
        <div class="article-nav-title">
          
            代码随想录
          
        </div>
      </a>
    
    
      <a href="/2022/01/28/git/" class="article-nav-link">
        <strong class="article-nav-caption">下一篇</strong>
        <div class="article-nav-title">git使用</div>
      </a>
    
  </nav>

  
     
</article>

</section>
      <footer class="footer">
  <div class="outer">
    <ul>
      <li>
        Copyrights &copy;
        2019-2022
        <i class="ri-heart-fill heart_icon"></i> Fakallhyy
      </li>
    </ul>
    <ul>
      <li>
        
        
        
        Powered by <a href="https://hexo.io" target="_blank">Hexo</a>
        <span class="division">|</span>
        Theme - <a href="https://github.com/Shen-Yu/hexo-theme-ayer" target="_blank">Ayer</a>
        
      </li>
    </ul>
    <ul>
      <li>
        
      </li>
    </ul>
    <ul>
      
    </ul>
    <ul>
      
    </ul>
    <ul>
      <li>
        <!-- cnzz统计 -->
        
        <script type="text/javascript" src='https://s9.cnzz.com/z_stat.php?id=1278069914&amp;web_id=1278069914'></script>
        
      </li>
    </ul>
  </div>
</footer>
      <div class="float_btns">
        <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>

<div class="todark" id="todark">
  <i class="ri-moon-line"></i>
</div>

      </div>
    </main>
    <aside class="sidebar on">
      <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/ayer-side.svg" alt="Fakallhyy&#39;Blog"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">主页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">归档</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/404">分类</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/404">标签</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/404">友链</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/404">关于我</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      <a class="nav-item-link nav-item-search"  title="Search">
        <i class="ri-search-line"></i>
      </a>
      
      
      <a class="nav-item-link" target="_blank" href="/atom.xml" title="RSS Feed">
        <i class="ri-rss-line"></i>
      </a>
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
    </aside>
    <script>
      if (window.matchMedia("(max-width: 768px)").matches) {
        document.querySelector('.content').classList.remove('on');
        document.querySelector('.sidebar').classList.remove('on');
      }
    </script>
    <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i>就当无事发生</p>
  <div class="reward-box">
    
    <div class="reward-item">
      <img class="reward-img" src="/images/alipa.jpg">
      <span class="reward-type">支付宝</span>
    </div>
    
    
    <div class="reward-item">
      <img class="reward-img" src="/images/wecha.jpg">
      <span class="reward-type">微信</span>
    </div>
    
  </div>
</div>
    
<script src="/js/jquery-2.0.3.min.js"></script>


<script src="/js/lazyload.min.js"></script>

<!-- Tocbot -->


<script src="/js/tocbot.min.js"></script>

<script>
  tocbot.init({
    tocSelector: '.tocbot',
    contentSelector: '.article-entry',
    headingSelector: 'h1, h2, h3, h4, h5, h6',
    hasInnerContainers: true,
    scrollSmooth: true,
    scrollContainer: 'main',
    positionFixedSelector: '.tocbot',
    positionFixedClass: 'is-position-fixed',
    fixedSidebarOffset: 'auto'
  });
</script>

<script src="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.js"></script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.css">
<script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js"></script>

<script src="/dist/main.js"></script>

<!-- ImageViewer -->

<!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.min.css">
<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script>

<!-- MathJax -->

<!-- Katex -->

<!-- busuanzi  -->

<!-- ClickLove -->

<!-- ClickBoom1 -->

<script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script>

<script src="/js/clickBoom1.js"></script>


<!-- ClickBoom2 -->

<!-- CodeCopy -->


<link rel="stylesheet" href="/css/clipboard.css">

<script src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js"></script>
<script>
  function wait(callback, seconds) {
    var timelag = null;
    timelag = window.setTimeout(callback, seconds);
  }
  !function (e, t, a) {
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '<i class="ri-file-copy-2-line"></i><span>COPY</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      $(".article pre code").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });
      clipboard.on('success', function(e) {
        let $btn = $(e.trigger);
        $btn.addClass('copied');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-checkbox-circle-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPIED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-checkbox-circle-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
      clipboard.on('error', function(e) {
        e.clearSelection();
        let $btn = $(e.trigger);
        $btn.addClass('copy-failed');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-time-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPY FAILED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-time-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
    }
    initCopyCode();
  }(window, document);
</script>


<!-- CanvasBackground -->


    
    <div id="music">
    
    
    
    <iframe frameborder="no" border="1" marginwidth="0" marginheight="0" width="200" height="52"
        src="//music.163.com/outchain/player?type=2&id=167679&auto=0&height=32"></iframe>
</div>

<style>
    #music {
        position: fixed;
        right: 15px;
        bottom: 0;
        z-index: 998;
    }
</style>
    
  </div>
</body>

</html>